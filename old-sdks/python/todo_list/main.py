import asyncio
import os
import sys
from dotenv import load_dotenv
from dataclasses import dataclass, field
from collections.abc import Sequence
from typing import Any, List, Literal, cast
from golem_base_sdk import Annotation, EntityKey, EntityMetadata, GenericBytes, GolemBaseClient, GolemBaseCreate, GolemBaseUpdate, decrypt_wallet
from datetime import datetime

APP_NAME = 'GOLEM_TODO_v1.0'

load_dotenv()

DBPASS = os.getenv('GOLEMDB_PASS')

if not DBPASS:
    print('Please set the GOLEMDB_PASS password in the .env file.')
    exit()

def str_to_entity_key(entity_id) -> EntityKey:
    entity_key = GenericBytes.from_hex_string(entity_id)
    return cast(EntityKey, entity_key) 

golem_client = None

async def get_client() -> GolemBaseClient:
    global golem_client
    if golem_client is None:
        private_key = await decrypt_wallet()
        golem_client = await GolemBaseClient.create_rw_client(
            rpc_url='http://localhost:8545',
            ws_url='ws://localhost:8545',
            private_key=private_key
        )
    return golem_client

@dataclass
class Todo:
    """
    A class representing a single to-do item.
    
    Attributes:
        name (str): The concise title of the task.
        description (str): A detailed explanation of the task.
        due_date (datetime): The target completion date and time.
        complete (bool): The status of the task (True if finished, False otherwise).
    """
    name: str
    description: str
    due_date: datetime
    complete: bool = field(default=False)
    app: str = field(default=APP_NAME)

@dataclass(frozen=True)
class AnnotationsContainer:
    """Class to hold a sequence of string and numeric annotations."""
    string_annotations: Sequence[Annotation[str]]
    numeric_annotations: Sequence[Annotation[int]]

def to_annotations(obj: Any) -> AnnotationsContainer:
    """
    Converts a Python object into an AnnotationsContainer.
    
    Order of checks is critical: Bool -> Numeric -> Datetime -> Other String.
    
    - Boolean attributes are explicitly converted to "True"/"False" string annotations.
    - Numeric attributes are converted to numeric annotations.
    - Datetime attributes are serialized to ISO 8601 string annotations.
    - All other attributes are converted to standard string annotations.
    """
    string_annotations = []
    numeric_annotations = []

    # Iterate over the object's attributes (assumes object has a __dict__)
    for key, value in obj.__dict__.items():
        # 1. Handle Booleans (must be before int/float check)
        if isinstance(value, bool):
            # Store as the string "True" or "False"
            string_annotations.append(Annotation(key, str(value)))
            
        # 2. Handle Numerics (int/float)
        elif isinstance(value, (int, float)):
            # Convert floats to int for numeric annotations
            numeric_annotations.append(Annotation(key, int(value)))
            
        # 3. Handle Datetimes
        elif isinstance(value, datetime):
            # Store as standardized ISO 8601 string
            string_annotations.append(Annotation(key, value.isoformat()))
            
        # 4. Fallback for all other types (stored as standard string)
        else:
            string_annotations.append(Annotation(key, str(value)))

    return AnnotationsContainer(
        string_annotations=string_annotations,
        numeric_annotations=numeric_annotations
    )

def from_annotations(annotations_container: EntityMetadata) -> dict[str, Any]:
    """
    Converts an AnnotationsContainer back into a Python dictionary.
    
    - Numeric annotations become integers.
    - String annotations are checked for Boolean, then Datetime, then fall back to String.
    """
    result = {}

    for annotation in annotations_container.string_annotations:
        value_str = annotation.value

        # 1. Check for Boolean strings (case sensitive, as generated by str(bool))
        if value_str == "True":
            result[annotation.key] = True
        elif value_str == "False":
            result[annotation.key] = False
        
        # 2. Check for Datetime strings (if not a boolean string)
        else:
            try:
                result[annotation.key] = datetime.fromisoformat(value_str)
            except ValueError:
                # 3. Fallback to a regular string
                result[annotation.key] = value_str

    for annotation in annotations_container.numeric_annotations:
        # Numeric annotations are already integers
        result[annotation.key] = annotation.value

    return result

async def get_full_list() -> List[EntityMetadata]:
    client: GolemBaseClient = await get_client()
    key_list = await client.query_entities(f'app="{APP_NAME}"')
    # Now need to iterate through the list, call get_entity_metadata on each member's entity_key
    # The following gets back a list of "promises" (to use TS terminology) or coroutine calls:
    metadata_tasks = [
        client.get_entity_metadata(str_to_entity_key(result.entity_key))
        for result in key_list
    ]
    metadata_sequence: List[EntityMetadata] = await asyncio.gather(*metadata_tasks)
    return metadata_sequence

async def get_todo_list_display_data(full_list: List[EntityMetadata], complete_status: Literal[True, False, None] = None) -> list[tuple[int, Todo]]:
    """
    Retrieves and deserializes todos, optionally filtering by completion status.
    Returns a list of tuples: (original_db_index, Todo_object).
    """
    todos_for_display = []

    # full_list: List[EntityMetadata] = await get_full_list()
    
    # Iterate through the database using index and container
    for index, annot_container in enumerate(full_list):
        # 1. Convert serialized annotations back to a Todo dictionary
        todo_dict = from_annotations(annot_container)
        
        # 2. Convert dictionary to a Todo object
        # NOTE: We use try/except as a simple safety for malformed data
        try:
            todo_obj = Todo(**todo_dict)
        except TypeError as e:
            print(f"Skipping malformed record at index {index}: {e}")
            continue

        # 3. Apply optional filtering
        if complete_status is None or todo_obj.complete == complete_status:
            # Store the index *plus one* for display, and the Todo object
            todos_for_display.append((index + 1, todo_obj))

    return todos_for_display


async def add_todo():
    """Add a new todo."""
    print("\n>>> Ready to add a new todo!")
    try:
        date_format = '%Y-%m-%d'

        name = input('Todo short name: ')
        desc = input('Todo longer description (one line): ')
        duedate_str = input('Please enter the due date (yyyy-mm-dd): ')

        obj = Todo(
            name=name,
            description=desc,
            due_date=datetime.strptime(duedate_str, date_format),
            complete=False
        )

        annot: AnnotationsContainer = to_annotations(obj)

        client: GolemBaseClient = await get_client()

        createable:GolemBaseCreate = GolemBaseCreate(name.encode('utf-8'), 60, annot.string_annotations, annot.numeric_annotations)
        print("Creating:")
        print(createable)
        receipt = await client.create_entities([createable])

        print("Results of create:")
        print(receipt)

        print(f"\nSUCCESS: Todo '{name}' added successfully.")

    except ValueError:
        print("Invalid input. Please enter valid information.")

async def list_todos():
    """List all todos, showing status and details."""
    full_list = await get_full_list()
    todos = await get_todo_list_display_data(full_list)

    print("\n" + "="*50)
    print("  CURRENT TODO LIST")
    print("="*50)

    if not todos:
        print("Your todo list is empty!")
        return

    # Sort incomplete tasks before complete tasks, and then by due date
    todos.sort(key=lambda x: (x[1].complete, x[1].due_date))

    for idx, todo in todos:
        status = "[DONE]" if todo.complete else "[PENDING]"
        due_date_str = todo.due_date.strftime('%Y-%m-%d')
        
        print(f"{idx:3}. {status} ({due_date_str}) - {todo.name}")
        print(f"      Description: {todo.description}")
        print(f"      Due: {todo.due_date}")
        
    print("="*50)    

async def mark_todo_complete():
    """Marks a todo complete"""

    full_list = await get_full_list()

    # Get only incomplete tasks, sorted by due date
    incomplete_todos = await get_todo_list_display_data(full_list, complete_status=False)
    
    if not incomplete_todos:
        print("\nSUCCESS: All pending todos are already complete! Nothing to mark.")
        return

    print("\n>>> Ready to mark a todo complete. Please choose a todo from the list below.")
    print("\n" + "-"*50)
    print("  PENDING TASKS")
    print("-"*50)

    # Use a separate counter for display, but keep the original index
    display_map = {} # Maps display number (1, 2, 3...) to original DB index
    for i, (original_index, todo) in enumerate(incomplete_todos):
        display_num = i + 1
        display_map[str(display_num)] = original_index
        
        due_date_str = todo.due_date.strftime('%Y-%m-%d')
        print(f"{display_num:3}. ({due_date_str}) - {todo.name}")
        
    print("-"*50)
    
    # Get user input for which task to mark complete
    choice = input("Enter the number of the task to mark as complete (or 'C' to cancel): ").strip().upper()
    
    if choice == 'C':
        print("Operation cancelled.")
        return
        
    if choice not in display_map:
        print("\n[ERROR] Invalid selection.")
        return

    # The original_db_index is the 1-based index (e.g., 1, 2, 3...)
    original_db_index = display_map[choice] 
    
    # Convert to 0-based index for Python list access
    db_index = original_db_index - 1
    
    # 1. Retrieve the existing serialized data from the database
    metadata = full_list[db_index]

    client: GolemBaseClient = await get_client()
    new_str_annots: Sequence[Annotation[str]] = []
    data = await client.get_storage_value(metadata.entity_key)
    for annot in metadata.string_annotations:
        if annot.key == 'complete':
            # Create the updated string annotation
            new_annot = Annotation(annot.key, 'True')
            new_str_annots.append(new_annot)
        else:
            new_str_annots.append(annot)
            
    result = await client.update_entities([
        GolemBaseUpdate(
            entity_key=metadata.entity_key,
            data = data,
            btl = 20,
            string_annotations = new_str_annots,
            numeric_annotations = metadata.numeric_annotations,
        )
    ])
    print(result)

# --- Main Menu Logic ---

def display_menu():
    """Prints the main menu to the console."""
    print("\n" + "="*30)
    print("  Todo List")
    print("="*30)
    print("1: Add Todo")
    print("2: List Todos")
    print("3: Mark a Todo Complete")
    print("Q: Quit Application")
    print("="*30)

async def menu_app():
    """The main application loop for the menu."""
    
    # Dictionary mapping user input (string) to the function to call
    menu_actions = {
        '1': add_todo,
        '2': list_todos,
        '3': mark_todo_complete
    }

    while True:
        display_menu()
        choice = input("Enter your selection (1-4 or Q): ").strip().upper()

        if choice == 'Q':
            print("\nExiting the application. Goodbye!")
            break  
        elif choice in menu_actions:
            # Call the function associated with the user's choice
            try:
                await menu_actions[choice]()
            except Exception as e:
                print(f"An unexpected error occurred: {e}")
        else:
            print(f"\n[ERROR] Invalid choice: '{choice}'. Please select an option from the menu.")
            

def main() -> None:
    asyncio.run(menu_app())

if __name__ == "__main__":
    main()
